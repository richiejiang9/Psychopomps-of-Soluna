<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_cursor</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-100000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Cursor Information

//Keeps track of where cursor is on the map array.
gridX = 0;
gridY = 0;

//Holds ID of the node that the cursor is on.
hoverNode = noone; 
hoverButton = noone;
buttonTimer = 0;

selectedCharacter = noone;

instance_create(0, 0, obj_select);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Cursor Controls

x = mouse_x;
y = mouse_y;

gridX = floor(x/GRID_SIZE);
gridY = floor(y/GRID_SIZE);

if(gridX &lt; 0 || gridY &lt; 0 || gridX &gt;= room_width/GRID_SIZE || gridY &gt;= room_height/GRID_SIZE)
{
    hoverNode = noone;
}
else
{
   hoverNode = map[gridX, gridY];
    
}

with(obj_confirmButton)
{
    if(keyboard_check_pressed(vk_enter) || keyboard_check_pressed(ord(hotkey)))
    {
        other.selectedCharacter.state = "perform action";
        instance_destroy();
    
    }

}

if(instance_place(x, y, obj_button))
{
    if(instance_place(x, y, obj_button) == hoverButton)
    {
        buttonTimer += 1;
    }
    else
    {
        buttonTimer = 0;
    }

    hoverButton = instance_place(x, y, obj_button);
    hoverNode = noone;

}
else
{
    hoverButton = noone;
    buttonTimer = 0;
}

with(obj_button)
{
    if(keyboard_check_pressed(ord(hotkey)))
    {
        scr_perform_buttons(obj_cursor.selectedCharacter, id);
    }

}

if(keyboard_check_pressed(vk_escape) &amp;&amp; selectedCharacter != noone)
{
    if(selectedCharacter.state == "begin action")
    {
        selectedCharacter.state = "idle";
        with(obj_confirmButton)
        {
            instance_destroy();
        }
        with(obj_confirmBox)
        {
            instance_destroy();
        }
    }
    with(obj_button)
    {
        instance_destroy();
    }
    
    scr_wipe_buttons();
    scr_wipe_nodes();

    scr_movement_range(map[selectedCharacter.gridX, selectedCharacter.gridY], selectedCharacter.move, selectedCharacter.actions);
   
    if(selectedCharacter.canAct)
    {
        switch(selectedCharacter.atkType)
        {
            case "ranged":
                scr_ranged_attack_range(selectedCharacter);
                break;
                
            case "melee":
                scr_melee_attack_range(selectedCharacter);
                break;
        
        }
    }
}



if(mouse_check_button_pressed(mb_left))
{
    if(selectedCharacter != noone &amp;&amp; hoverButton != noone)
    {
        scr_perform_buttons(selectedCharacter, hoverButton);
        
    }
    
    if(instance_place(x, y, obj_confirmButton))
    {
        selectedCharacter.state = "perform action";
        with(obj_confirmButton)
        {
            instance_destroy();
        }
    
    }

    if(instance_place(x, y, obj_endBox))
    {
        with(obj_fadeLose)
        {
            finalize = true;
        }
        with(obj_endBox)
        {
            instance_destroy();
        }
    }

}

if(mouse_check_button_pressed(mb_right))        //Moves the character to the desired place.
{
    if(hoverNode != noone){
    if(selectedCharacter != noone &amp;&amp; hoverNode.moveNode)
    {
        current = hoverNode;    //Sets the current character to the hoverNode
        
        scr_create_path(selectedCharacter, current) //Calls create path script
        
        //Clear node of selected character and update grid coords
        map[selectedCharacter.gridX, selectedCharacter.gridY].occupant = noone;
        
        selectedCharacter.gridX = gridX;
        selectedCharacter.gridY = gridY;
        
        //Updates coords of the selected character
        hoverNode.occupant = selectedCharacter;
        
        //Pathing begins
        selectedCharacter.state = "begin path";
        selectedCharacter.endPath = "ready";
        
        if(hoverNode.G &gt; selectedCharacter.move)
        {
            selectedCharacter.actions = -2;
            scr_wipe_buttons();
            scr_wipe_nodes();
            
        }
        else
        {
            selectedCharacter.actions -= 1;
            scr_wipe_buttons();
            scr_wipe_nodes();

        }
        
        selectedCharacter = noone;
    }
    
    if(selectedCharacter != noone &amp;&amp; hoverNode.atkNode) //When the selected character can attack a targetted enemy
    {
        switch(selectedCharacter.atkType)   //Type of attack depends on the character's atkType variable
        {
            case "ranged":  //For ranged attackers
                selectedCharacter.canAct = false;       //Action is over
                selectedCharacter.actions -= 1;         //Used up an action
                selectedCharacter.atkTarget = hoverNode.occupant;   //The target on the node will be selected
                selectedCharacter.state = "begin attack";    //attack state begins
                selectedCharacter.actionTimer = 10;
            
                selectedCharacter = noone;  //Wipes selected character
                scr_wipe_buttons();
                scr_wipe_nodes();
                
                break;
                
            case "melee":   //for melee attackers
                selectedCharacter.canAct = false;       //Action is over
                selectedCharacter.atkTarget = hoverNode.occupant;   //The target on the node will be selected
                
                tempX = abs(hoverNode.gridX - selectedCharacter.gridX);
                tempY = abs(hoverNode.gridY - selectedCharacter.gridY);
                
                if(tempX &lt;= 1 &amp;&amp; tempY &lt;= 1)
                {
                    selectedCharacter.actions -= 1; //Used up an action
                    selectedCharacter.state = "begin attack";    //attack state begins
                    selectedCharacter.actionTimer = 10;
                
                    selectedCharacter = noone;  //Wipes selected character
                    scr_wipe_buttons();
                    scr_wipe_nodes();
                }
                else
                {
                    tempG = 100; //Find closest attackable neighbor
                    current = noone;
                    
                    for(ii = 0; ii &lt; ds_list_size(hoverNode.neighbors); ii += 1)
                    {
                        tempNode = ds_list_find_value(hoverNode.neighbors, ii)
                        
                        if(tempNode.occupant == noone &amp;&amp; tempNode.G &gt; 0 &amp;&amp; tempNode.G &lt; tempG)
                        {
                            tempG = tempNode.G;
                            current = tempNode;
                        }
                        
                        
                    }
                    
                    targetNode = current;
                    scr_create_path(selectedCharacter, targetNode);
                    
                    //Clear node of selected character and update grid coords
                    map[selectedCharacter.gridX, selectedCharacter.gridY].occupant = noone;
                    
                    selectedCharacter.gridX = targetNode.gridX;
                    selectedCharacter.gridY = targetNode.gridY;
                    
                    targetNode.occupant = selectedCharacter;
                    
                    //Pathing begins
                    selectedCharacter.state = "begin path";
                    selectedCharacter.endPath = "begin attack";
                    selectedCharacter.atkTarget = hoverNode.occupant;
                    selectedCharacter.actions -= 2;
                    selectedCharacter.canAct = false;
                    
                    selectedCharacter = noone;
                    scr_wipe_buttons();
                    scr_wipe_nodes();
                    
                    
                }
                break;
            
        }
        
    }   //atkNode ends here
    
    if(hoverNode.actionNode)
    {
        selectedCharacter.state = "perform action";
        with(obj_confirmBox)
        {
            instance_destroy();
        }
        with(obj_confirmButton)
        {
            instance_destroy();
        }
    }
    }
    
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Cursor Draws
draw_self();
if(hoverButton != noone &amp;&amp; buttonTimer &gt; 15)
{
    tempTitle = hoverButton.title;
    tempText = hoverButton.text;
    
    draw_set_font(f_crit);
    
    heightY = string_height(tempTitle) + string_height(tempText);
    
    draw_set_color(c_black);
    draw_rectangle(x + 20, y - heightY, x + 20 + string_width(tempTitle), y - heightY + string_height(tempTitle), false);
    
    draw_set_color(c_white);
    draw_text(x + 20, y - heightY, tempTitle);
    
    draw_set_font(f_default);
    draw_set_color(c_black);
    draw_rectangle(x + 20, y - string_height(tempText), x + 20 + string_width(tempText), y, false);
    
    draw_set_color(c_white);
    draw_text(x + 20, y - string_height(tempText), tempText);
    
}

if(selectedCharacter != noone)
{
    tempText = selectedCharacter.firstName;     //DISPLAYS NAME
    tempHitPoints = "HP: " + string(selectedCharacter.hitPoints) + "/" + string(selectedCharacter.maxHP);
    tempAtkText = "ATK: " + string(selectedCharacter.atk); 
    tempDexText = "DEX: " + string(selectedCharacter.dex); 
    tempHitText = "HIT: " + string(selectedCharacter.hit); 
    tempMagText = "MAG: " + string(selectedCharacter.mag); 
    tempAtkDiceText = "AtkDice: " + string(selectedCharacter.dmgDice) + " " + string(selectedCharacter.atkType); 
        
    if(selectedCharacter.firstName == "Claretta Martone")
    {
        instance_create(0, room_height, obj_ClarettaPortrait);
    }
    else if (selectedCharacter.firstName == "Freed Danvers")
    {
        instance_create(0, room_height, obj_FreedPortrait);
    }
    else if (selectedCharacter.firstName == "Marisol Reyes")
    {
        instance_create(0, room_height, obj_MarisolPortrait);
    }
    else if (selectedCharacter.firstName == "Roland Nakamura")
    {
        instance_create(0, room_height, obj_RolandPortrait);
    }
    
    draw_set_color(c_black);
    draw_rectangle(0, room_height - 80, string_width(tempHitPoints), room_height - 80 - string_height(tempHitPoints), false);
    draw_rectangle(0, room_height - 96, string_width(tempText), room_height - 96 - string_height(tempText), false);
    draw_rectangle(0, room_height - 64, string_width(tempAtkText), room_height - 64 - string_height(tempAtkText), false);
    draw_rectangle(0, room_height - 48, string_width(tempAtkText), room_height - 48 - string_height(tempDexText), false);
    draw_rectangle(0, room_height - 32, string_width(tempAtkText), room_height - 32 - string_height(tempHitText), false);
    draw_rectangle(0, room_height - 16, string_width(tempAtkText), room_height - 16 - string_height(tempMagText), false);
    draw_rectangle(0, room_height, string_width(tempAtkDiceText), room_height - string_height(tempAtkDiceText), false);
        
    draw_set_color(c_white);
    draw_text(0, room_height - 80 - string_height(tempText), tempHitPoints);
    draw_text(0, room_height - 96 - string_height(tempText), tempText); //Draws textboxs for names and HP total
    draw_text(0, room_height - 64 - string_height(tempText), tempAtkText);
    draw_text(0, room_height - 48 - string_height(tempText), tempDexText);
    draw_text(0, room_height - 32 - string_height(tempText), tempHitText);
    draw_text(0, room_height - 16 - string_height(tempText), tempMagText);
    draw_text(0, room_height - string_height(tempText), tempAtkDiceText);
}

if(selectedCharacter == noone)
{
    with(obj_portrait)
    {
        instance_destroy();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
