<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Basic Necessities

instance_create(x, y, obj_fadeIn);
draw_set_font(f_default);

///Node/Tile Creation
//Runs the terrain state machine when state is set to "initializing".
state = "initializing";


//Randomizes a set order for turn orders.
randomize();

turnOrder = ds_list_create();
turnCounter = -1;
turnMax = 0;
currentCharacter = noone;
roundCounter = 0;

//Array that holds on to the IDs of all node objs.
globalvar map;

//Holds the size of the map by nodes.
mapWidth = room_width/GRID_SIZE;        
mapHeight = room_height/GRID_SIZE;

//Create nodes
for(xx = 0; xx &lt; mapWidth; xx += 1)
{
    for(yy = 0; yy &lt; mapHeight; yy += 1)
    {
        map[xx, yy] = instance_create(xx * GRID_SIZE, yy * GRID_SIZE, obj_node);
        map[xx, yy].gridX = xx;
        map[xx, yy].gridY = yy;
    }
}

//Populate edge neighbor lists
for(xx = 0; xx &lt; mapWidth; xx += 1)
{
    for(yy = 0; yy &lt; mapHeight; yy += 1)
    {
        node = map[xx, yy];     //Cannot be 0 for x or y.
        
        //Left neighbor
        if(xx &gt; 0)
        {
            ds_list_add(node.neighbors, map[xx - 1, yy]);
        }
        
        //Right neighbor
        if(xx &lt; mapWidth -1)
        {
            ds_list_add(node.neighbors, map[xx + 1, yy]);
        }
        
        //Top neighbor
        if(yy &gt; 0)
        {
            ds_list_add(node.neighbors, map[xx, yy - 1]);
        }
        
        //Bottom neighbor
        if(yy &lt; mapHeight - 1)
        {
            ds_list_add(node.neighbors, map[xx, yy + 1]);
        }
        
        //Top left neighbor
        if(xx &gt; 0 &amp;&amp; yy &gt; 0)
        {
            ds_list_add(node.neighbors, map[xx - 1, yy - 1]);
        }
        
        //Top right neighbor
        if(xx &lt; mapWidth - 1 &amp;&amp; yy &gt; 0)
        {
            ds_list_add(node.neighbors, map[xx + 1, yy - 1]);
        }
        
        //Bottom left neighbor
        if(xx &gt; 0 &amp;&amp; yy &lt; mapHeight - 1)
        {
            ds_list_add(node.neighbors, map[xx - 1, yy + 1]);
        }
        
        //Bottom right neighbor
        if(xx &lt; mapWidth - 1 &amp;&amp; yy &lt; mapHeight - 1)
        {
            ds_list_add(node.neighbors, map[xx + 1, yy + 1]);
        }
    }
}

//Creates the fancy cursor.
instance_create(x, y, obj_cursor);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Terrain States and Turn Order/Attack Steps
if(keyboard_check_pressed(vk_delete))
{
    obj_cursor.selectedCharacter = noone;
    obj_control.currentCharacter = noone;
    with(obj_character)
    {
        if(side == PSYCHOPOMPS)
        {
            instance_destroy();
        }
    }
    scr_wipe_nodes();
    scr_wipe_buttons();
}



switch(state)
{
    case "initializing":
        with(obj_node)
        {
            if(instance_position(x + 16, y + 16, obj_terrain))
            {
                tempTerrain = instance_position(x + 16, y + 16, obj_terrain);
                
                switch(tempTerrain.type)
                {       
                        
                    case "wall":
                        instance_change(obj_wall, true);
                        type = "wall";
                        passable = false;
                        
                        break;
                    
                    case "rubble":
                        instance_change(obj_rubble, true);
                        type = "rubble";
                        cost = 1.5;
                        break;
                    
                }
                
                with(tempTerrain)
                {
                instance_destroy();
                
                }
            
            }
            
            if(instance_position(x + 16, y +16, obj_character))
            {
                occupant = instance_position(x + 16, y + 16, obj_character);
                occupant.gridX = gridX;
                occupant.gridY = gridY;
            
            }
            
        }
        state = "roll init";
        break;
        
    case "roll init":
        tempInit = ds_priority_create();
        
        with(obj_character)
        {
            initRoll = irandom_range(1, 20) + initiative;
            
            ds_priority_add(other.tempInit, id, initRoll);
        
        }
        
        while(ds_priority_size(tempInit) &gt; 0)
        {
            ds_list_add(turnOrder, ds_priority_delete_max(tempInit));
        }
        
        turnMax = ds_list_size(turnOrder);
        ds_priority_destroy(tempInit);
        
        state = "waiting";
        
        break;
        
    case "ready":
        if(currentCharacter == noone)
        {
            psychopompCount = 0;
            ghostCount = 0;
            
            with(obj_character)
            {
                if(side == GHOSTS)
                {
                    other.ghostCount += 1;
                }
                if(side == PSYCHOPOMPS)
                {
                    other.psychopompCount += 1;
                }
            }
            
            if(psychopompCount &gt; 0 &amp;&amp; ghostCount &gt; 0)
            {
            
                turnCounter += 1;
                
                if(turnCounter &gt;= turnMax)
                {
                    turnCounter = 0;
                    roundCounter += 1;
                }
                currentCharacter = ds_list_find_value(turnOrder, turnCounter);
                
                if(instance_exists(currentCharacter))
                {
                    currentCharacter.actions = 2;
                               
                    currentCharacter.canAct = true;
                    
                    currentCharacter.state = "initialize turn";
                }
                else
                {
                    currentCharacter = noone;
                }
            }
            else
            {
                if(psychopompCount &lt;= 0)
                {
                    state = "retry room";
                }
                else
                {
                    state = "next room";
                }
            }
            
        }
    
        break;
        
    case "retry room":
        instance_create(0, 0, obj_fadeLose);
        state = "waiting";
        
        break;
    
    case "next room":
        instance_create(0, 0, obj_fadeWin);
        state = "waiting";
        break;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="71">
      <action>
        <libid>1</libid>
        <id>222</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_next_room</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
